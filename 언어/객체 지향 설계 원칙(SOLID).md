# 객체 지향 설계 원칙(SOLID)

객체지향 설계 원칙은 **시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 다섯 가지 원칙**으로,   
앞 글자를 따 SOLID 원칙이라고도 한다.   
SOLID 객체 지향 원칙을 적용하면 코드를 확장하고 유지 보수 관리하기가 더 쉬워지며, 불필요한 복잡성을 제거해 리팩토링에 소요되는 시간을 줄임으로써 프로젝트 개발의 생산성을 높일 수 있다.

<br>

### 단일 책임 원칙(SRP: Single Responsibility Principle)
- **한 클래스는 단 하나의 책임만 가져야 한다.**
  <br>
  
	> 모듈이 변경되는 이유가 한가지여야한다는 것으로 받아들여야 한다.<br>
  >   - 여기서 변경의 이유가 한가지라는 것 : 해당 모듈이 여러 대상 또는 액터들에 대해 책임을 가져서는 안되고, 오직 하나의 액터에 대해서만 책임을 져야 한다는 것을 의미
  >   - '책임'은 하나의 '기능 담당'으로 보면 된다.
 
- 응집도는 높고, 결합도는 낮게 설계하는 것을 의미

하나의 클래스에 여러 기능이 있다면 기능 변경이 일어났을 때 수정해야 할 코드가 많아진다.<br>
따라서 이 원칙을 따름으로써 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄작용을 극복할 수 있다. 


<br>

### 개방-폐쇄 원칙(OCP: Open-closed Principle)
- 기존의 코드를 변경하지 않고도 기능을 추가할 수 있도록 설계해야 한다.
- 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다.
  
    - 확장에 열려있다 : 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애클리케이션의 기능을 확장할 수 있다.
    - 수정에 닫혀있다 : 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정하는 것을 제한한다.

- 추상화(인터페이스)와 상속(다형성) 등을 통해 구현 가능
  - 자주 변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고도 기능을 확장할 수 있도록 함으로써 유연함을 높이는 것이 핵심

<br>

### 리스코프 치환 원칙(LSP: Liskov Substitution Principle)
- 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야한다.<br>
  (자식클래스는 부모클래스의 역할을 할 수 있어야한다.)
- 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야한다.

<br>

### 인터페이스 분리 원칙(ISP: Interface Segregation Principle)
- 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다.
  - 하나의 통상적인 인터페이스보다 여러개의 세부적인 인터페이스가 낫다.
  - 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 하는 것이 핵심
- 단일 책임 원칙(SRP)이 객체가 갖는 하나의 책임이라면, 인터페이스 분리 원칙(ISP)은 인터페이스가 갖는 하나의 책임이다.

<br>

### 의존 역전 원칙(DIP: Dependency Inversion Principle)
- 각 객체들 간의 의존 관계가 성립될 때, 구체적인 것 보다 추상적인 것(추상클래스나 인터페이스)에 의존해야 한다.
- 일반적으로 인터페이스를 활용하면 이 원칙은 준수된다.

<br>

##

[출처]<br>
- [링크](https://velog.io/@haero_kim/SOLID-%EC%9B%90%EC%B9%99-%EC%96%B4%EB%A0%B5%EC%A7%80-%EC%95%8A%EB%8B%A4)<br>
- [링크](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID)
